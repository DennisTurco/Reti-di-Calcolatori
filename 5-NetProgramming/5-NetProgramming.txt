Autore: Dennis Turco

=========================================================| PROGRAMMAZIONE SOCKET |=========================================================
    In questo caso ho creato 2 versioni:
    
    1. Versione in linea con la richiesta:
        file: gethostbyname.py, gethostbyaddr.py
        Inserisco una associazione nome-IP nel file /etc/hosts quindi verifico le gethostbyname() e gethostbyaddr() 
        prima consultando il file locale /etc/hosts poi se necessario eseguo una query DNS.

        copio il programma "gethostbyname.py" ed utilizzandolo come template creo "gethostbyaddr.py".
        inserisco un associazione nel file /etc/hosts: 180.150.25.11 www.provauni.it

            file modificato:
                # This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to />
                # [network]
                # generateHosts = false
                127.0.0.1       localhost
                127.0.1.1       DENNO-PC-SEEEEEH.localdomain    DENNO-PC-SEEEEEH
                127.0.0.1       rockstarmodders.com
                127.0.0.1       rockstarmodders2.com
                127.0.0.1       rockstarmodders3.com
                127.0.0.1       rockstarmodders4.com
                127.0.0.1       rockstarmodders5.com
                127.0.0.1       rockstarmoddersalter.com
                127.0.0.1       prod.rockstarreports.com
                127.0.0.1       modders.ros.rockstargames.com
                127.0.0.1       modders.ros2.rockstargames.com
                180.150.25.11 www.provauni.it                          --> ASSOCIAZIONE AGGIUNTA
                ....

        Esempio Funzionamento:
        input: python gethostbyname.py www.provauni.it
        output: Name: www.provauni.it --> Host: 180.150.25.11
            

    2. Versione personale:
        file: gethostbyname_versione_estesa.py, gethostbyaddr_versione_estesa.py
        In questa versione è possibile modificare direttamente il file "/etc/hosts" tramite
        programma, interrogandolo per verificare la presenza di un host e se non presente all'interno del file,
        viene aggiunta la tupla (indirizzo IPv4, nome host) nella posizione corretta del file.

        Esempio sul funzionamento:
        - a. caso in cui lo trova:
        input:  sudo python gethostbyname_versione_estesa.py www.provauni.it
        output: name address: www.provauni.it founded in file /etc/hosts
                Name: www.provauni.it --> Host: 180.150.25.11

        - b. caso in cui non lo trova:
        input:  sudo python gethostbyname_versione_estesa.py www.google.com
        output: host address: 142.250.184.68 added in file /etc/hosts
                Name: www.google.com --> Host: 142.250.184.68

                file: etc/hosts/
                    # This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /># [network]
                    # generateHosts = false
                    127.0.0.1       localhost
                    127.0.1.1       DENNO-PC-SEEEEEH.localdomain    DENNO-PC-SEEEEEH
                    127.0.0.1       rockstarmodders.com
                    127.0.0.1       rockstarmodders2.com
                    127.0.0.1       rockstarmodders3.com
                    127.0.0.1       rockstarmodders4.com
                    127.0.0.1       rockstarmodders5.com
                    127.0.0.1       rockstarmoddersalter.com
                    127.0.0.1       prod.rockstarreports.com
                    127.0.0.1       modders.ros.rockstargames.com
                    127.0.0.1       modders.ros2.rockstargames.com
                    180.150.25.11 www.provauni.it
                    142.250.184.68    www.google.com    --> AGGIUNTO AUTOMATICAMENTE
                    ....
        

=========================================================| PROGRAMMAZIONE UDP |=========================================================
    Ho scaricato e modificato come richiesto i file:
        - dgram_client.py
        - dgram_server.py
        - echo_client.py
        - echo_server.py

    Innanzitutto, nelle impostazioni della macchina virtuale ho aggiunto una regola di "Port Fowarding" e ho inserito:
        - Name = udp;
        - Protocol = UDP;
        - HOST IP = ;
        - HOST Port = 10102;
        - GUEST IP = ;
        - GUEST Port = 10102;

    Successivamente ho aperto 2 terminali: 
        1. nella virtual machine (che fungerà da server)
        2. su windows (che fungerà da client)

    
    1. PUNTO DGRAM: Questo programma esegue una comunicazione senza riscontro.
        Terminale macchina virtuale (server): 
            input: python dgram_server.py
            output: 
                    port: 10102  server:0.0.0.0 bufsize: 1024
                addr: ('10.0.2.2', 62269)  data: b'hello from Dennis Turco, in python'

        Terminale macchina client: 
            input: python dgram_client.py -s 160.78.143.10 -p 10102  (dove 160.78.143.10 indirizzo ipv4 della macchina client connessa alla VPN dell'università ottenuta con: hostname -I)
            output: 
                OPTIONS  server: 160.78.143.10  - port: 10102  - bufsize: 100
                sent  34  Bytes

                time : 0.0005247592926025391
    
    2. PUNTO ECHO: Questo programma esegue una comunicazione con riscontro sullo stesso socket.
        Terminale macchina virtuale (server): 
            input: python echo_server.py
            output: 
                    port: 10102  server:0.0.0.0 bufsize: 1024
                from: ('10.0.2.2', 55701)  data: b'hello from Dennis Turco, in python'
                to: ('10.0.2.2', 55701)  data: b'hello from Dennis Turco, in python'
                ---------------------------

        Terminale macchina client: 
            input: python dgram_client.py -s 160.78.143.10 -p 10102  (dove 160.78.143.10 indirizzo ipv4 della macchina client connessa alla VPN dell'università ottenuta con: hostname -I)
            output: 
                OPTIONS  server: 160.78.143.10 - port: 10102  - message: b'hello from Dennis Turco, in python'
                to:  ('160.78.143.10', 10102) - data:  b'hello from Dennis Turco, in python'
                from: ('160.78.143.10', 10102) - data: b'hello from Dennis Turco, in python'
                tempo : 0.0013637542724609375

PERCHÈ C'È SCRITTO: python dgram_client.py ...... ??????????????????

=========================================================| PROGRAMMAZIONE TCP |=========================================================
    Ho scaricato e modificato come richiesto i file:
        - echotcp-client.py
        - echotcp-server-thread.py
        - echotcp2-client.py
        - echotcp2_server-thread.py

    Innanzitutto, nelle impostazioni della macchina virtuale ho aggiunto una regola di "Port Fowarding" e ho inserito:
        - Name = echo;
        - Protocol = TCP;
        - HOST IP = ;
        - HOST Port = 10102;
        - GUEST IP = ;
        - GUEST Port = 10102;
    
    come prima ho aperto 2 terminali: 
        1. nella virtual machine (che fungerà da server)
        2. su windows (che fungerà da client)

 
    1. PUNTO ECHOTCP: Questo programma esegue una comunicazione con riscontro su un socket diverso.
         Terminale macchina virtuale (server): 
            input: python echotcp-server-thread.py
            output: 
                OPTIONS  server: 0.0.0.0  - port: 10102
                starting up on port: ('0.0.0.0', 10102)
                waiting for a connection
                connection from the client: ('10.0.2.2', 51240)
                received: hello
                sent: hello

        Terminale macchina client: 
            input:  python echotcp-client.py    oppure
                    python echotcp-client.py -s 160.78.143.10 -p 10102
            output: 
                OPTIONS  server: localhost  - port: 10102  - message: b'hello from Turco, in python'
                Connected to server: ('localhost', 10102)
                Send message: hello
                Server response: hello

    
    2. PUNTO ECHOTCP2: Questo programma esegue una comunicazione persistente con riscontri su diversi socket.
        Terminale macchina virtuale (server): 
            input: python echotcp2-server-thread.py
            output: 
                OPTIONS  server: 0.0.0.0  - port: 10102
                server bind on port: ('0.0.0.0', 10102)
                waiting for a connection
                connection from the client: ('10.0.2.2'. 51429)
                message received: prova messaggio da client 
                message sent: prova messaggio da client
                message received: ciao server
                message sent: ciao server
                closed connection from: ('10.0.2.2', 51457)

        Terminale macchina client: 
            input:  python echotcp2-client.py    oppure
                    python echotcp2-client.py -s 160.78.143.10 -p 10102
            output: 
                OPTIONS  server: localhost  - port: 10102  - message: hello from Dennis Turco, in python
                Connected to server: ('localhost', 10102)
                message (q to quit) > prova messaggio da client
                Server response:  prova messaggio da client
                message (q to quit) > ciao server
                Server response:  ciao server
                message (q to quit) > q